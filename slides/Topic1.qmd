---
title: "Short Course on R Tools"
subtitle: "Object-Oriented Programming in R"
title-slide-attributes:
  data-background-image: mu-bg.png
  data-background-size: stretch
  data-slide-number: none
format: 
  revealjs:
    transition: fade
    scrollable: true
---

# Outline

::: {.fragment .fade-up}
-   OOP Paradigms in R
-   Base Types & Functional OOP
-   S3 Classes & Methods
-   S4 Classes & Methods
-   R6 Classes & Reference Semantics
-   Trade-offs & Best Practices
-   Hands-on Exercises
:::

# OOP Paradigms in R {auto-animate="true"}

-   **Functional OOP**: functions return objects, operate on data

::: panel-tabset
## Code

```{r}
#| label: basic
#| fig-show: hide
#| message: false

par(mfrow=c(1,3))
plot(iris$Sepal.Length)
plot(iris$Species)
# plot(iris[,1:3])
# plot(lm(Sepal.Length ~ Sepal.Width, data=iris))
```

## Plots

```{r}
#| ref.label: basic
#| echo: false
#| fig-asp: 0.3
```
:::

# OOP Paradigms in R {auto-animate="true"}

-   **Encapsulated OOP**: objects carry data + methods

::: shrink-code
``` {.r code-line-numbers="1|2-4|5-6|7-8"}
library(xgboost)
data(iris)
X <- as.matrix(iris[, 1:4])
y <- as.numeric(iris$Species) - 1
model <- xgboost(data = X, label = y, nrounds = 10,
                 objective = "multi:softprob", num_class = 3, verbose = 0)
# Real use of object$method(args)
preds <- model$predict(xgb.DMatrix(X))
```
:::

. . .

-   **Generics & Method Dispatch**

. . .

-   **When to use**: design, extensibility, code organization

# OOP in R {auto-animate="true"}

::: incremental
-   **S3** is R’s first OOP system, which is an informal implementation of functional OOP.

-   **S4** is a formal and rigorous rewrite of S3. S4 is implemented in the base *methods* package, which is always installed with R.

-   **RC** implements encapsulated OO.

-   **R6** implements encapsulated OOP like RC, but resolves some important issues.
:::

# OOP in R {auto-animate="true"}

``` {.r code-line-numbers="1|4-5|8-9|12-14"}
library(sloop)


otype(1:10)
#> [1] "base"


otype(mtcars)
#> [1] "S3"


mle_obj <- stats4::mle(function(x = 1) (x - 2) ^ 2)
otype(mle_obj)
#> [1] "S4"
```

. . .

![](images/oop/oo-venn.png){.absolute top="0" right="0"}

# Base versus OO objects

``` {.r code-line-numbers="1|2-3|5|6-7"}
# A base object:
is.object(1:10)
#> [1] FALSE

# An OO object
is.object(mtcars)
#> [1] TRUE
```

. . .

-   Technically, the difference between base and OO objects is that OO objects have a “class” attribute:

``` {.r code-line-numbers="1-2|4-5"}
attr(1:10, "class")
#> NULL

attr(mtcars, "class")
#> [1] "data.frame"
```

# Base Types

-   Every object has a **base type**. In total, there are 25 different base types. Here are some examples:

::: shrink-code
``` {.r code-line-numbers="1-2|3-4|5-6|7-8|9-10|11-12|13-14|15-17"}
typeof(NULL)
#> [1] "NULL"
typeof(1L)
#> [1] "integer"
typeof(1i)
#> [1] "complex"
typeof(mean)
#> [1] "closure"
typeof(`[`)
#> [1] "special"
typeof(sum)    
#> [1] "builtin"
typeof(globalenv())
#> [1] "environment"
mle_obj <- stats4::mle(function(x = 1) (x - 2) ^ 2); typeof(mle_obj)
#> [1] "S4"
```
:::

# S3: Informal Classes

-   **Lightweight**: no formal schema

. . .

-   **Define**: set `class` attribute

. . .

```{r}
x <- structure(c(1,2,3), class = "myclass")
mean(x)
```

. . .

```{r}
mean.myclass <- function(x, ...) {
  print("custom mean")
}
mean(x)
```

## Basics

-   An S3 object is a base type with at least a `class` attribute

::: shrink-code
``` {.r code-line-numbers="1-4|5-10|11-14|16-18|20|21-35"}
f <- factor(c("a", "b", "b"))
f
#> [1] a b b
#> Levels: a b
attributes(f)
#> $levels
#> [1] "a" "b"
#> 
#> $class
#> [1] "factor"
unclass(f)
#> [1] 1 2 2
#> attr(,"levels")
#> [1] "a" "b"

time <- strptime(c("2017-01-01", "2020-05-04 03:21"), "%Y-%m-%d")
str(time)
#>  POSIXlt[1:2], format: "2017-01-01" "2020-05-04"

class(time) <- NULL
str(time)
#> List of 11
#>  $ sec   : num [1:2] 0 0
#>  $ min   : int [1:2] 0 0
#>  $ hour  : int [1:2] 0 0
#>  $ mday  : int [1:2] 1 4
#>  $ mon   : int [1:2] 0 4
#>  $ year  : int [1:2] 117 120
#>  $ wday  : int [1:2] 0 1
#>  $ yday  : int [1:2] 0 124
#>  $ isdst : int [1:2] 0 0
#>  $ zone  : chr [1:2] "UTC" "UTC"
#>  $ gmtoff: int [1:2] 0 0
#>  - attr(*, "tzone")= chr "UTC"
#>  - attr(*, "balanced")= logi TRUE
```
:::

## Classes

``` {.r code-line-numbers="1-2|4-6|8-9|10-11|12-13"}
# Create and assign class in one step
x <- structure(list(), class = "my_class")

# Create, then set class
x <- list()
class(x) <- "my_class"

class(x)
#> [1] "my_class"
inherits(x, "my_class")
#> [1] TRUE
inherits(x, "your_class")
#> [1] FALSE
```

. . .

-   R doesn’t stop you from shooting yourself in the foot, but as long as you don’t aim the gun at your toes and pull the trigger, you won’t have a problem.

## Classes - Common Practice

To avoid foot-bullet intersections when creating your own class, you may:

::: incremental
-   A low-level constructor, `new_myclass()`, that efficiently creates new objects with the correct structure.
-   A validator, `validate_myclass()`, that performs more computationally expensive checks to ensure that the object has correct values.
-   A user-friendly helper, `myclass()`, that provides a convenient way for others to create objects of your class.
:::

## Classes - Example

::: shrink-code
``` {.r code-line-numbers="1-9|11-26|28-33|35-49|51-58"}
## 1. Low‐level constructor: assume inputs are ok
new_myclass <- function(values = numeric(), unit = character(1)) {
  # no checks here beyond base‐R stopifnot
  stopifnot(is.numeric(values), is.character(unit), length(unit) == 1)
  structure(
    list(values = values, unit = unit),
    class = "myclass"
  )
}

## 2. Validator: more thorough checks
validate_myclass <- function(x) {
  if (!inherits(x, "myclass")) {
    stop("`x` must be a 'myclass' object.", call. = FALSE)
  }
  if (!is.numeric(x$values)) {
    stop("`values` must be numeric.", call. = FALSE)
  }
  if (any(is.na(x$values))) {
    stop("`values` must not contain NA.", call. = FALSE)
  }
  if (!is.character(x$unit) || length(x$unit) != 1) {
    stop("`unit` must be a single character string.", call. = FALSE)
  }
  TRUE
}

## (Optional) a simple print method
print.myclass <- function(x, ...) {
  cat("<myclass>  ", length(x$values), "values [unit = ", x$unit, "]\n", sep = "")
  print(x$values)
  invisible(x)
}

## 3. User‐facing helper: coerce/check inputs, then build + validate
myclass <- function(values, unit = "unitless") {
  # quick checks / coercions:
  if (!is.numeric(values)) {
    values <- as.numeric(values)
    if (any(is.na(values))) stop("`values` could not be coerced to numeric.", call. = FALSE)
  }
  if (!is.character(unit) || length(unit) != 1) {
    stop("`unit` must be a single character string.", call. = FALSE)
  }
  # build & validate
  obj <- new_myclass(values = values, unit = unit)
  validate_myclass(obj)
  obj
}

## --- Example usage ---
x <- myclass(c(1.1, 2.2, 3.3), unit = "kg")
print(x)
#> <myclass> 3 values [unit = kg]
#> [1] 1.1 2.2 3.3

# This will error because of an NA:
# myclass(c(1, NA, 3))
```
:::

## Generics and Methods - Method Dispatch

``` {.r code-line-numbers="1-3|5-6|7-8|10-12|13-16"}
View(print)
#> function (x, ...) 
#> UseMethod("print")

ftype(print)
#> [1] "S3"      "generic"
ftype(print.factor)
#> [1] "S3"     "method"

s3_dispatch(print(f))
#> => print.factor
#>  * print.default
s3_dispatch(print(unclass(f)))
#>    print.integer
#>    print.numeric
#> => print.default
```

## Finding methods

``` {.r code-line-numbers="1-11|13-23"}
s3_methods_generic("mean")
#> # A tibble: 7 × 4
#>   generic class      visible source             
#>   <chr>   <chr>      <lgl>   <chr>              
#> 1 mean    Date       TRUE    base               
#> 2 mean    default    TRUE    base               
#> 3 mean    difftime   TRUE    base               
#> 4 mean    POSIXct    TRUE    base               
#> 5 mean    POSIXlt    TRUE    base               
#> 6 mean    quosure    FALSE   registered S3method
#> 7 mean    vctrs_vctr FALSE   registered S3method

s3_methods_class("funts")
#> # A tibble: 7 × 4
#>   generic class visible source             
#>   <chr>   <chr> <lgl>   <chr>              
#> 1 -       funts FALSE   registered S3method
#> 2 *       funts FALSE   registered S3method
#> 3 [       funts FALSE   registered S3method
#> 4 +       funts FALSE   registered S3method
#> 5 length  funts FALSE   registered S3method
#> 6 plot    funts FALSE   registered S3method
#> 7 print   funts FALSE   registered S3method
```

## Creating methods

::: {style="margin-top: 20px;"}
```{r}
mean.myclass <- function(x, ...) {
  print("custom mean")
}

mean(x)
```
:::

. . .

::: {style="margin-top: 20px;"}
-   A method must have the same arguments as its generic. This is enforced in packages by `R CMD check`.
:::

. . .

-   There is one exception to this rule: if the generic has `...`, the method can contain a superset of the arguments. This allows methods to take arbitrary additional arguments.

## Inheritance

``` {r}
class(x$values)
class(ordered(x$values))
s3_dispatch(print(ordered(x$values)))
s3_dispatch(ordered(x$values)[1])
```

## Key Points

-   `class(x)` order

-   NextMethod()

-   Overloading + inheritance via class vectors

??? note Demo: create `print.myclass`, show dispatch.

# S3 Constructors & Validation

-   **Constructor function**:

    ``` r
    new_myclass <- function(x) {
      stopifnot(is.numeric(x))
      structure(x, class = "myclass")
    }
    ```

-   **Validation**: manual checks in constructor

-   **Pros/Cons**: flexible vs fragile

??? note Emphasize lack of formal slot checks.

# S4: Formal Classes

-   **Definition**: `setClass()` with slots

``` r
setClass("Person",
  slots = list(
    name = "character",
    age  = "numeric"
  )
)
```

-   **Create instance**: `new("Person", name = "Alice", age = 30)`

??? note Illustrate slot access via `@` and `slot()`.

# S4 Generics & Methods

-   **Define generic**:

    ``` r
    setGeneric("greet", function(x) standardGeneric("greet"))
    ```

. . .

-   **Define method**:

    ``` r
    setMethod("greet", "Person", function(x) {
      paste("Hello, my name is", x@name)
    })
    ```

-   **Multiple dispatch**: based on argument classes

??? note Show example with inheritance & dispatch.

# S4 Inheritance & Virtual Classes

-   **Inheritance**:

    ``` r
    setClass("Employee", contains = "Person",
      slots = list(salary = "numeric"))
    ```

-   **Virtual classes**: abstract base types

-   **Validity methods**: `setValidity()`

??? note Encourage robust class definitions.

# R6: Reference Classes

-   **Encapsulated OOP**: mutable fields + methods

-   **Define**:

    ``` r
    library(R6)
    PersonR6 <- R6Class("PersonR6",
      public = list(
        name = NULL,
        initialize = function(name) self$name <- name,
        greet = function() cat("Hi, I'm", self$name, "\n")
      )
    )
    ```

-   **Instantiate & use**:

    ``` r
    p <- PersonR6$new("Bob")
    p$greet()
    ```

??? note Compare reference vs value semantics.

# R6 Advanced Features

-   **Active bindings**

-   **Inheritance & extension**

-   **Private vs public**

-   **Use cases**: GUI, stateful objects, iterative algorithms

??? note Show leak-free design with private fields.

# Trade-offs & Best Practices

| Paradigm | Pros               | Cons                           |
|----------|--------------------|--------------------------------|
| S3       | Simple, flexible   | No schema, fragile dispatch    |
| S4       | Formal, robust     | Verbose, steep learning curve  |
| R6       | Encapsulated, fast | Manual memory, low abstraction |

-   Choose based on complexity & team skill

-   Document constructors & methods clearly

-   Write unit tests for OO code

??? note Discuss package design implications.

# Hands-on Exercises (30 min)

1.  **Create S3 class**: define `circle` with `radius` and methods for area & print

2.  **S4 hierarchy**: model shapes (`Shape` virtual, `Circle`, `Rectangle` classes)

3.  **R6 counter**: implement counter with reset and step-by-step logging

??? note Split into small groups, reconvene for solutions.

# Resources & References

-   **Advanced R**: OO chapters by Hadley Wickham

-   R Documentation: `?Methods`, `?R6Class`

-   CRAN packages: `methods`, `R6`

-   Articles: stat.ethz.ch/\~jlamp/news/oop

??? note Encourage further reading and experimentation.

# Q&A

-   Questions on paradigms?

-   Real-world use cases?

-   Integration with functional programming?

# Thank You

-   Slides source: adv-r OO chapter

-   Feedback welcome!
