---
title: "Short Course on R Tools"
subtitle: "Integrate Python in R using Reticulate"
title-slide-attributes:
  data-background-image: mu-bg.png
  data-background-size: stretch
  data-slide-number: none
format: 
  revealjs:
    transition: fade
    scrollable: true
---

# Outline {.scrollable}

::: incremental
-   Why integrate Python into R?
-   What is `reticulate`?
-   Installation & Setup
-   Importing Python Modules into R
-   Python Objects & Data Conversion
-   Sourcing Python Scripts in R
-   Data Conversion & Accessing R Objects in Python
-   Working with Python Classes in R
-   reticulate in R Markdown & Quarto
:::

# 1. Why integrate Python into R? {.scrollable}

::: incremental
-   **Access powerful Python libraries:** R has excellent packages, but some cutting-edge tools exist only in Python:
    -   Deep Learning: `PyTorch`, `TensorFlow`, `Keras`
    -   Machine Learning: `scikit-learn`, `XGBoost`, `LightGBM`
    -   NLP: `spaCy`, `HuggingFace transformers`
    -   Computer Vision: `OpenCV`
-   **Combine the best of both worlds**
    -   R: data manipulation, statistics, visualization (`ggplot2`, `dplyr`)
    -   Python: ML/AI, scripting, general programming
:::

# 

-   **Reuse existing Python code**
    -   Avoid rewriting code or switching environments

::: incremental
-   **Create seamless interactive workflows**
    -   Mix R and Python in R Markdown, Jupyter, or Quarto documents
-   **Enhance productivity and reproducibility**
    -   Use the right tool for each task in one unified workflow
:::

# 2. What is `reticulate`?

::: incremental
-   R package for interoperability with Python

-   Maintains a shared Python session accessible from R

-   Automatic conversion of many R types to Python and vice versa

-   Supports inline Python code in R Markdown and R scripts
:::

# 3. Installation & Setup

üß© **Install the `reticulate` package in R**

``` r
install.packages("reticulate")
```

. . .

üêç **Ensure Python is installed**<br/> Use system Python, Anaconda, or a virtual environment. You can check the Python configuration in R:

``` r
library(reticulate)
py_available() # Check python availability
```

. . .

``` text
[1] FALSE
```

. . .

``` r
py_config() #Inspect current setup
```

. . .

**üîó Bind to a specific Python version**

``` r
# use_python("C://Users//your_username/AppData/Local/Programs/Python/Python312")
```

# 4. Importing Python Modules into R

**üì¶ Use `import()` to bring Python modules into R**

``` {.r code-line-numbers="1|2|3" height="200"}
library(reticulate)
np$mean(c(1, 2, 3, 4))  
```

. . .

``` text
[1] 2.5
```

. . .

**üì¶ Use `import_builtins()` to import Python built-in functions**

``` r
py_builtins <- import_builtins()
py_builtins$len(c(1, 2, 3))   
```

. . .

``` text
[1] 3
```

# 5. Sourcing Python Scripts in R {transition="slide"}

-   Use `source_python()` or `py_run_file()` to run `.py` scripts from R
-   Use `py_run_string()` to run inline Python code from R

## üì• Using `source_python()` {transition="convex"}

Variables become **directly available in the R global environment**

. . .

**üîç Example:**

Consider "script.py" file, includes following Python script:

``` python
y = 2
def square(x):
    return x **2
```

. . .

‚úÖ Works directly in R :

``` r
library(reticulate)
source_python("script.py")
square(4)
```

. . .

``` text
[1] 16
```

. . .

``` r
print(y) 
```

. . .

``` text
2
```

## üì• Using `py_run_file()` {transition="zoom"}

Also runs the script, but...

::: incremental
-   ‚ùå Does not expose functions/variables directly in R
-   Variables and functions are stored in `py$`
:::

. . .

``` {.r code-line-numbers="1|2" height="200"}
py_run_file("script.py")
py$square(4)
```

. . .

``` text
[1] 16
```

. . .

``` r
print(py$y)
```

. . .

``` text
2
```

## üß© Using `py_run_string()` {transition="slide"}

::: incremental
-   Executes the string in the shared Python session
-   Variables created in Python are not added to R environment
-   Access Python variables in R using `py$`
:::

. . .

``` {.r code-line-numbers="1-5|6" height="200"}
py_run_string("
def square(x):
    return x ** 2
y = 5
")
py$y
```

. . .

``` text
[1] 5
```

. . .

``` r
py$square(4)
```

. . .

``` text
[1] 16
```

# 6. Data Conversion & Accessing R Objects in Python {transition="zoom"}

## üîÅ Automatic Data Conversion {transition="slide"}

::: small
| R Object Type | Python Equivalent | Notes |
|-------------------------|-----------------------------|------------------|
| `numeric`, `integer` | `float`, `int` | Scalars or arrays |
| `logical` | `bool` | TRUE ‚Üí `True` |
| `character` | `str` or `list[str]` | Vectorized strings ‚Üí list |
| `vector`, `matrix` | `numpy.ndarray` | Shape preserved |
| `data.frame` | `pandas.DataFrame` | Column types preserved |
| `list` (named) | `dict` | Keys from names |
| `list` (unnamed) | `list` | Sequential list |
| `NULL` | `None` |  |
| `function` (closure) | Python callable | If inputs/outputs are convertible |
| `function` (builtin) | ‚ùå PyCapsule | ‚ö†Ô∏è not callable in Python |
| `S3/S4/R6` objects | ‚ùå PyCapsule | ‚ö†Ô∏è Not convertible |

: {tbl-colwidths="\[30,30,40\]"}
:::

## Accessing R Objects from Python {transition="slide"}

**üîç Example:**<br/> Let two following objects have been defined in R global environment:

``` r
library(reticulate)
x <- c(10, 20, 30)
f <- function(x) x^2
```

. . .

In Python we can access to these objects trough `r` object:

``` python
print(r.x)      
[10, 20, 30]
print(r.f(3))  
```

. . .

``` text
9
```

## Exporting R Objects to Python {transition="slide"}

Use `py$` assignment. In R:

``` {.r code-line-numbers="1-3|5"}
library(reticulate)
x <- c(1, 2, 3)
py$x <- x        # Exports `x` to Python namespace
f <- function(n) n^2
py$f <- f        # Exports R function to Python
```

. . .

Now usable from Python:

``` python
print(x) 
```

. . .

``` text
[1, 2, 3]
```

. . .

``` r
print(f(5))
```

. . .

``` text
[1] 25
```

## Exporting R Closure Functions to Python {transition="slide"}

A **closure** in R is simply a user-defined function created with the function() keyword. It's the most common type of function in R.

‚úÖ A **closure** fnction Works directly. In R:

``` r
py$m <- mean
typeof(mean) 
```

. . .

``` text
[1] "closure"
```

. . .

In Python:

``` python
print(m([1, 2, 3, 4, 5]))     
```

. . .

``` text
3
```

## Exporting R `Builtin` Functions to Python {transition="slide"}

**Built-in** functions in R are functions implemented in C (compiled) and embedded directly into the R interpreter.

‚ö†Ô∏è Builtin function needs wrapping. For example:

``` r
typeof(exp) # return "builtin"
py$e <- e
```

. . .

In Python:

``` python
print(e(1))     
```

. . .

``` text
TypeError: 'PyCapsule' object is not callable
```

. . .

‚úÖ Solution: Wrap the builtin in a closure

``` r
e <- function(x) exp(x)
py$e <- e
```

. . .

In Python:

``` python
print(e(1))  # ‚úÖ Returns 2.718
```

## üé• Demo: Python from R in RStudio

{{< video images/python/reticulate.mp4 >}}

# 7. Working with Python Classes in R

## üß© Create a Python class and use it in R

You can define a Python class (e.g., a neural network in PyTorch) and interact with it from R using `reticulate`.

. . .

**üß™ Python File: `simple_net.py`**

``` {.python code-line-numbers="1|3|4-6|8-9"}
import torch.nn as nn

class SimpleNet(nn.Module):
    def __init__(self, n_input):
        super().__init__()
        self.fc = nn.Linear(n_input, 1)

    def forward(self, x):
        return self.fc(x)
```

## 

**üñ•Ô∏è R Code to Load and Use the Python Class:**

``` {.r code-line-numbers="1-2|4-5|7-9|11-13"}
library(reticulate)
source_python("simple_net.py")

# Create model instance
model <- SimpleNet(5L)

# Create input tensor (2 samples, 5 features)
torch$manual_seed(42L)
x <- torch$randn(c(2L, 5L))

# Forward pass
output <- model(x)
print(output)
```

. . .

``` text
tensor([[-0.0285],
        [-0.4532]], grad_fn=<AddmmBackward0>)
```

# üí° Deep Learning Example

**Goal**:\
Use a **pretrained Python CNN** (PyTorch) in **R** to predict digits from MNIST test images.

. . .

**Workflow**:\

1. Train CNN in Python ‚Üí Save model weights. 

2. Load model & preprocess in R using `reticulate`. 

3. Predict & visualize results in R.

## üìÇ Project Structure

```text
project/
‚îú‚îÄ‚îÄ model.py # Python torch model  
‚îú‚îÄ‚îÄ train.py # Python training code 
‚îú‚îÄ‚îÄ cnn_model.pth # Saved PyTorch weights 
‚îî‚îÄ‚îÄ test_images/ # A few PNGs from MNIST test set
```

## üêç Python: model.py

```{python}
import torch.nn as nn
import torch.nn.functional as F

class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.conv1_layer = nn.Conv2d(1, 16, kernel_size=3, padding=1)
        self.conv2_layer = nn.Conv2d(16, 32, kernel_size=3, padding=1)
        self.fc1_layer = nn.Linear(32 * 7 * 7, 128)
        self.fc2_layer = nn.Linear(128, 10)

    def forward(self, inputs):
        x = F.relu(self.conv1_layer(inputs))
        x = F.max_pool2d(x, kernel_size=2, stride=2)
        x = F.relu(self.conv2_layer(x))
        x = F.max_pool2d(x, kernel_size=2, stride=2)
        x = x.view(-1, 32 * 7 * 7)
        x = F.relu(self.fc1_layer(x))
        x = self.fc2_layer(x)
        return x
```

## MINIST Dataset
![](images/python/minist.png){fig-align="center" fig-alt="Screenshot of Pagerank" width="55%"}

## üêç Python: Training & Saving

``` python
import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
from torch.utils.data import DataLoader
from model import SimpleCNN

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")

data_transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.5,), (0.5,))
])

train_dataset = torchvision.datasets.MNIST(root='./data', train=True, transform=data_transform, download=False)
test_dataset = torchvision.datasets.MNIST(root='./data', train=False, transform=data_transform, download=False)

train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=64, shuffle=False)

cnn_model = SimpleCNN().to(device)
loss_func = nn.CrossEntropyLoss()
optimizer = optim.Adam(cnn_model.parameters(), lr=0.001)

for epoch in range(5):
    cnn_model.train()
    running_loss = 0.0
    for inputs, labels in train_loader:
        inputs, labels = inputs.to(device), labels.to(device)
        optimizer.zero_grad()
        outputs = cnn_model(inputs)
        loss = loss_func(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
    print(f"Epoch {epoch+1}, Loss: {running_loss / len(train_loader):.4f}")

cnn_model.eval()
correct_predictions = 0
total_samples = 0
with torch.no_grad():
    for inputs, labels in test_loader:
        inputs, labels = inputs.to(device), labels.to(device)
        outputs = cnn_model(inputs)
        _, predicted_labels = torch.max(outputs, 1)
        total_samples += labels.size(0)
        correct_predictions += (predicted_labels == labels).sum().item()

accuracy = 100 * correct_predictions / total_samples
print(f"Accuracy of test set: {accuracy:.2f}%")

torch.save(cnn_model.state_dict(), 'cnn_model.pth')
```

## üîó R: Load the Python Model

``` r
library(reticulate)

torch <- import("torch")
Image <- import("PIL.Image", convert = FALSE)
plt <- import("matplotlib.pyplot")
transforms <- import("torchvision.transforms", convert = TRUE)
source_python("model.py") # Loads SimpleCNN
os <- import("os")

device <- torch$device("cpu")
model <- SimpleCNN()$to(device)
model$load_state_dict(torch$load("cnn_model.pth", map_location = device))
model$eval()
```

## üñº Preprocess & Predict in R

``` r
transform <- transforms$Compose(list(
  transforms$Grayscale(),
  transforms$Resize(tuple(28L, 28L)),
  transforms$ToTensor(),
  transforms$Normalize(tuple(0.5), tuple(0.5))
))

image_dir <- "test_images"
image_files <- sort(Filter(function(f) endsWith(f, ".png"), os$listdir(image_dir)))

plt$figure(figsize = tuple(10, 3))

with(torch$no_grad(), {
  for (idx in seq_along(image_files)) {
    image <- Image$open(file.path(image_dir, image_files[[idx]]))
    input_tensor <- transform(image)$unsqueeze(0L)$to(device)
    output <- model(input_tensor)
    predicted_label <- torch$argmax(output, dim = 1L)$item()
    
    plt$subplot(1L, length(image_files), idx)
    plt$imshow(image$convert("L"), cmap = "gray")
    plt$title(sprintf("Predicted: %s", predicted_label))
    plt$axis("off")
  }
})
plt$tight_layout()
plt$show()
```

## Prediction plot
![](images/python/pred_minist.png){fig-align="center" fig-alt="Screenshot of Pagerank" width="55%"}

# 8. reticulate in R Markdown & Quarto

```` markdown
```{.python}
import numpy as np
x = np.arange(10)
```
````

-   **Chunk engines**: `{python}`, `{python3}`
-   **Return to R**:

``` r
r_vec <- py$x
```

-   **Quarto YAML**:

``` yaml
execute:
  echo: true
```

# 9. Shiny & Python Integration

üß¨ Run Python code dynamically inside a Shiny app using `reticulate`

``` {.r code-line-numbers="1-2|3-6|7-13|14"}
library(shiny)
library(reticulate)
ui <- fluidPage(
  actionButton("btn", "Compute in Python"),
  verbatimTextOutput("out")
)
server <- function(input, output) {
  observeEvent(input$btn, {
    # Run Python code when button is clicked
    py_run_string("import math; res = math.factorial(10)")
    output$out <- renderText(py$res)
  })
}
shinyApp(ui, server)
```

# 10. Hands-on Exercises (30 min)

1.  **Create environment** and import a Python library (e.g., seaborn)
2.  **Write Python function** in `.py` and call it from R
3.  **Convert** a pandas DataFrame to R and back
4.  **Embed** Python chunk in a Quarto doc and render

# Resources & Further Reading

-   reticulate docs: <https://rstudio.github.io/reticulate/>
-   Tutorials: RStudio blog posts
-   Community: RStudio Community forums

# üôè Thank you!

Questions & Discussion
